### JPA의 데이터 타입 분류
- 엔티티 타입
	- @Entity로 정의하는 객체
	
- 값타입
	- 기본값 타입, 임베디드 타입, 컬렉션 값 타입으로 나뉘어짐



### 임베디드 타입
- 엔티티에서 사용되는 기본값 타입들을 모아 새로운 값 타입으로 직접 정의한 타입
- 예) Member 엔티티는 이름/근무 시작일/ 근무 종료일/ 주소도시, 주소 번지, 주소 우편번호를 가진다. 
- AS-IS MEMBER entity
- ![[Pasted image 20250918134310.png]]
- startDate, endDate 를 묶어 Period 라는 이름의 새로운 객체로 만들어줌
- city, street, zipcode를 묶어 Address라는 새로운 객체로 만들어줌

- TO-BE MEMBER entity
- ![[Pasted image 20250918134409.png]]
- ![[Pasted image 20250918134454.png]]


![[Pasted image 20250918134617.png]]
#### 임베디드 타입의 장점
- 재사용이 용이해짐
- 높은 응집도
- Period.isWork() 처럼 해당 값 타입만 사용하는 의미있는 메소드를 만들 수 있다.
- 임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티의 생명주기를 의존한다.

#### 임베디드 타입 사용법
- Embeddable: 값 타입을 정의하는 곳에 표시
- Embedded: 값 타입을 사용하는 곳에  표시
- 임베디드 타입은 기본 생성자가 필수다
- 임베디드 타입의 값이 null이면 매핑한 컬럼 값은 모두 null


#### @AttributeOverride
- 한 엔티티에서 같은 값 타입을 사용하면 컬럼명이 중복되어 오류가 발생함 -> 어트리뷰트오버라이드 어노테이션을 사용해서 컬럼명 속성을 재정의




### 값 타입 사용시 주의할 점
- 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함
- 왜? 값 타입은 (Java 기본 타입은 제외) 참조로 관리되기 때문에 재사용시 다른 엔티티의 값도 변경됨
- ##### 따라서 수정을 할 수 없게 만들어 부작용을 원천 차단 => 값타입은 불변 객체로 설계 해야한다.
- 불변객체: 생성 후에는 절대 값을 변경할 수 없는 객체
- 불변객체 만들기: 예) 생성자로만 값을 설정하고 setter를 만들지 않는다.


### 값 타입의 비교
- 값 타입은 a.equals(b)를 사용해서 동등성 비교를 해야한다. 
- equals() 메소드를 적절하게 재정의해야함